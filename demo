import React, { useRef, useEffect } from 'react';
import { setPixel } from '../utils/image';
import { EnergyMap as EnergyMapType } from '../utils/contentAwareResizer';

type EnergyMapProps = {
  energyMap: EnergyMapType | null,
  width: number,
  height: number,
  className?: string,
};

const normalizeEnergy = (
  energy: number,
  maxEnergy: number,
  maxNormalizedEnergy: number,
): number => {
  return Math.floor((energy / maxEnergy) * maxNormalizedEnergy);
};

const getMaxEnergy = (
  energyMap: EnergyMapType,
  width: number,
  height: number,
): number => {
  let maxEnergy = 0;
  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      maxEnergy = Math.max(maxEnergy, energyMap[y][x]);
    }
  }

  return maxEnergy;
};

const normalizeEnergyMap = (
  energyMap: EnergyMapType,
  width: number,
  height: number,
  maxNormalizedEnergy = 255,
): number[][] => {
  const maxEnergy = getMaxEnergy(energyMap, width, height);

  const normalizedMap = new Array(height)
    .fill(null)
    .map(() => {
      return new Array(width).fill(Infinity);
    });

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      normalizedMap[y][x] = normalizeEnergy(energyMap[y][x], maxEnergy, maxNormalizedEnergy);
    }
  }

  return normalizedMap;
};

const EnergyMap = (props: EnergyMapProps): React.ReactElement => {
  const {
    energyMap,
    className,
    width,
    height,
  } = props;

  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    if (!energyMap || !energyMap.length || !energyMap[0].length) {
      return;
    }
    const energyCanvas: HTMLCanvasElement | null = canvasRef.current;
    if (!energyCanvas) {
      return;
    }
    const energyCtx: CanvasRenderingContext2D | null = energyCanvas.getContext('2d');
    if (!energyCtx) {
      return;
    }

    energyCanvas.width = width;
    energyCanvas.height = height;

    const imgData: ImageData = energyCtx.getImageData(0, 0, width, height);

    const normalizedEnergyMap = normalizeEnergyMap(energyMap, width, height);

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const norm = normalizedEnergyMap[y][x];
        setPixel(imgData, { x, y }, [norm, norm, norm, 255]);
      }
    }

    energyCtx.putImageData(imgData, 0, 0);
  }, [energyMap, width, height]);

  return (
    <canvas ref={canvasRef} className={className} />
  );
};

export default EnergyMap;

import React, { useEffect, useRef, useState } from 'react';
import { ImShrink2 } from '@react-icons/all-files/im/ImShrink2';
import { FaRegHandPointer } from '@react-icons/all-files/fa/FaRegHandPointer';

import {
  EnergyMap as EnergyMapType,
  Seam,
  OnIterationArgs,
  ImageSize,
  resizeImage,
  ALPHA_DELETE_THRESHOLD,
  MAX_WIDTH_LIMIT,
  MAX_HEIGHT_LIMIT,
} from '../utils/contentAwareResizer';
import EnergyMap from './EnergyMap';
import Seams from './Seams';
import defaultImgSrc from '../assets/02.jpg';
import Button, { BUTTON_KIND_SECONDARY } from './Button';
import FileSelector from './FileSelector';
import Checkbox from './Checkbox';
import Progress from './Progress';
import Input from './Input';
import FadeIn from './FadeIn';
import Mask from './Mask';
import { Coordinate, getPixel, setPixel } from '../utils/image';
import { MdLayersClear } from '@react-icons/all-files/md/MdLayersClear';

const defaultWidthScale = 50;
const defaultHeightScale = 70;
const minScale = 1;
const maxScale = 100;
const maxWidthLimit = MAX_WIDTH_LIMIT;
const maxHeightLimit = MAX_HEIGHT_LIMIT;

type ImageResizerProps = {
  withSeam?: boolean,
  withEnergyMap?: boolean,
};

const ImageResizer = (props: ImageResizerProps): React.ReactElement => {
  const {
    withSeam = false,
    withEnergyMap = false,
  } = props;

  const [imgAuthor, setImgAuthor] = useState<string | null>('ian dooley');
  const [imgAuthorURL, setImgAuthorURL] = useState<string | null>(
    'https://unsplash.com/@sadswim?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText',
  );

  const [useNaturalSize, setUseNaturalSize] = useState<boolean>(false);
  const [imageSrc, setImageSrc] = useState<string>(defaultImgSrc);
  const [resizedImgSrc, setResizedImgSrc] = useState<string | null>(null);
  const [energyMap, setEnergyMap] = useState<EnergyMapType | null>(null);
  const [originalImgSize, setOriginalImgSize] = useState<ImageSize | null>(null);
  const [originalImgViewSize, setOriginalImgViewSize] = useState<ImageSize | null>(null);
  const [workingImgSize, setWorkingImgSize] = useState<ImageSize | null>(null);
  const [seams, setSeams] = useState<Seam[] | null>(null);
  const [isResizing, setIsResizing] = useState<boolean>(false);
  const [progress, setProgress] = useState<number>(0);
  const [maskImgData, setMaskImgData] = useState<ImageData | null>(null);
  const [maskRevision, setMaskRevision] = useState<number>(0);
  const [toWidthScale, setToWidthScale] = useState<number>(defaultWidthScale);
  const [toWidthScaleString, setToWidthScaleString] = useState<string | undefined>(`${defaultWidthScale}`);
  const [toHeightScale, setToHeightScale] = useState<number>(defaultHeightScale);
  const [toHeightScaleString, setToHeightScaleString] = useState<string | undefined>(`${defaultHeightScale}`);

  const imgRef = useRef<HTMLImageElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  const onUseOriginalSizeChange = (state: boolean): void => {
    setUseNaturalSize(state);
  };

  const onReset = (): void => {
    setResizedImgSrc(null);
    setSeams(null);
    setWorkingImgSize(null);
    setEnergyMap(null);
    setProgress(0);
    setOriginalImgViewSize(null);
  };

  const onFileSelect = (files: FileList | null): void => {
    if (!files || !files.length) {
      return;
    }
    setImgAuthor(null);
    setImgAuthorURL(null);
    onReset();
    const imageURL = URL.createObjectURL(files[0]);
    setImageSrc(imageURL);
  };

  const onWidthSizeChange = (size: string | undefined): void => {
    const radix = 10;
    const scale = Math.max(Math.min(parseInt(size || '0', radix), maxScale), minScale);
    if (size) {
      setToWidthScaleString(`${scale}`);
    } else {
      setToWidthScaleString(size);
    }
    setToWidthScale(scale);
  };

  const onHeightSizeChange = (size: string | undefined): void => {
    const radix = 10;
    const scale = Math.max(Math.min(parseInt(size || '0', radix), maxScale), minScale);
    if (size) {
      setToHeightScaleString(`${scale}`);
    } else {
      setToHeightScaleString(size);
    }
    setToHeightScale(scale);
  };

  const onFinish = (): void => {
    if (!canvasRef.current) {
      return;
    }
    const imageType = 'image/png';
    canvasRef.current.toBlob((blob: Blob | null): void => {
      if (!blob) {
        return;
      }
      const imgUrl = URL.createObjectURL(blob);
      setResizedImgSrc(imgUrl);
      setIsResizing(false);
    }, imageType);
  };

  const onClearMask = (): void => {
    setMaskRevision(maskRevision + 1);
  };

  const onMaskDrawEnd = (imgData: ImageData): void => {
    setMaskImgData(imgData);
  };

  const applyMask = (img: ImageData): void => {
    if (!maskImgData) {
      return;
    }

    const wRatio = maskImgData.width / img.width;
    const hRatio = maskImgData.height / img.height;

    const imgXYtoMaskXY = ({ x: imgX, y: imgY }: Coordinate): Coordinate => {
      return {
        x: Math.floor(imgX * wRatio),
        y: Math.floor(imgY * hRatio),
      };
    };

    for (let y = 0; y < img.height; y += 1) {
      for (let x = 0; x < img.width; x += 1) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [mR, mG, mB, mA] = getPixel(
          maskImgData,
          imgXYtoMaskXY({ x, y }),
        );
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [iR, iG, iB, iA] = getPixel(img, { x, y });
        if (mA) {
          setPixel(img, { x, y }, [iR, iG, iB, ALPHA_DELETE_THRESHOLD]);
        }
      }
    }
  };

  const onIteration = async (args: OnIterationArgs): Promise<void> => {
    const {
      seam,
      img,
      energyMap: nrgMap,
      size: { w, h },
      step,
      steps,
    } = args;

    const canvas: HTMLCanvasElement | null = canvasRef.current;
    if (!canvas) {
      return;
    }

    canvas.width = w;
    canvas.height = h;

    const ctx: CanvasRenderingContext2D | null = canvas.getContext('2d');
    if (!ctx) {
      return;
    }

    ctx.putImageData(img, 0, 0, 0, 0, w, h);

    setEnergyMap(nrgMap);
    setSeams([seam]);
    setWorkingImgSize({ w, h });
    setProgress(step / steps);
  };

  const onResize = (): void => {
    const srcImg: HTMLImageElement | null = imgRef.current;
    if (!srcImg) {
      return;
    }
    const canvas: HTMLCanvasElement | null = canvasRef.current;
    if (!canvas) {
      return;
    }

    onReset();
    setIsResizing(true);

    let w = useNaturalSize ? srcImg.naturalWidth : srcImg.width;
    let h = useNaturalSize ? srcImg.naturalHeight : srcImg.height;
    const ratio = w / h;

    setOriginalImgViewSize({
      w: srcImg.width,
      h: srcImg.height,
    });

    if (w > maxWidthLimit) {
      w = maxWidthLimit;
      h = Math.floor(w / ratio);
    }

    if (h > maxHeightLimit) {
      h = maxHeightLimit;
      w = Math.floor(h * ratio);
    }

    canvas.width = w;
    canvas.height = h;

    const ctx: CanvasRenderingContext2D | null = canvas.getContext('2d');
    if (!ctx) {
      return;
    }

    ctx.drawImage(srcImg, 0, 0, w, h);

    const img: ImageData = ctx.getImageData(0, 0, w, h);

    applyMask(img);

    const toWidth = Math.floor((toWidthScale * w) / 100);
    const toHeight = Math.floor((toHeightScale * h) / 100);

    resizeImage({
      img,
      toWidth,
      toHeight,
      onIteration,
    }).then(() => {
      onFinish();
    });
  };

  useEffect(() => {
    const srcImg: HTMLImageElement | null = imgRef.current;
    if (!srcImg) {
      return;
    }
    srcImg.addEventListener('load', () => {
      if (!imgRef.current) {
        return;
      }
      setOriginalImgSize({
        w: imgRef.current.naturalWidth,
        h: imgRef.current.naturalHeight,
      });
      setOriginalImgViewSize({
        w: imgRef.current.width,
        h: imgRef.current.height,
      });
    });
  }, []);

  useEffect(() => {
    function updateSize(): void {
      if (!imgRef.current) {
        return;
      }
      setOriginalImgViewSize({
        w: imgRef.current.width,
        h: imgRef.current.height,
      });
    }
    window.addEventListener('resize', updateSize);
    return (): void => {
      window.removeEventListener('resize', updateSize);
    };
  }, []);

  const imgAuthorLink = imgAuthor && imgAuthorURL ? (
    <div className="text-xs text-gray-400 mt-2 flex justify-center items-center font-light">
      <div className="mr-1">
        Photo by
      </div>
      <a
        href={imgAuthorURL}
        style={{ color: '#aaa', fontWeight: 300 }}
        target="_blank"
        rel="noreferrer"
      >
        {imgAuthor}
      </a>
    </div>
  ) : null;

  const seamsCanvas = withSeam && workingImgSize && seams ? (
    <div style={{ marginTop: `-${workingImgSize.h}px` }}>
      <Seams seams={seams} width={workingImgSize.w} height={workingImgSize.h} />
    </div>
  ) : null;

  const originalImageSizeText = originalImgSize ? (
    <sup className="text-xs text-gray-400 whitespace-nowrap">
      {`${originalImgSize.w} x ${originalImgSize.h} px`}
    </sup>
  ) : null;

  const maskControls = (
    <div>
      <Button
        onClick={onClearMask}
        disabled={isResizing || !maskImgData}
        kind={BUTTON_KIND_SECONDARY}
        title="Clear mask"
        className="rounded-full"
        style={{ padding: '8px 8px', border: 0, outline: 'none' }}
      >
        <MdLayersClear size={16} />
      </Button>
    </div>
  );

  const mask = originalImgViewSize ? (
    <div className="flex flex-col" style={{ marginTop: `-${originalImgViewSize.h}px` }}>
      <Mask
        width={originalImgViewSize.w}
        height={originalImgViewSize.h}
        disabled={isResizing}
        onDrawEnd={onMaskDrawEnd}
        revision={maskRevision}
      />
      <div className="flex flex-row justify-end" style={{ marginTop: '-36px', zIndex: 100 }}>
        <div className="mr-1">
          {maskControls}
        </div>
      </div>
    </div>
  ) : null;

  const originalImage = (
    <FadeIn>
      <div className="flex flex-row justify-center items-center mb-1 sm:mb-0">
        <div className="flex-1 sm:flex sm:flex-row sm:items-center">
          <div className="sm:flex-1">
            <b>Original image</b> {originalImageSizeText}
          </div>
          <div className="text-xs text-gray-400 flex flex-row items-center justify-self-end">
            <div className="mr-1">
              <FaRegHandPointer size={12} />
            </div>
            <div>
              Mask to remove
            </div>
          </div>
        </div>
      </div>
      <img src={imageSrc} alt="Original" ref={imgRef} style={{ margin: 0 }} />
      {mask}
      {imgAuthorLink}
    </FadeIn>
  );

  const workingImageScrollableText = (
    workingImgSize?.w && originalImgViewSize?.w && workingImgSize.w > originalImgViewSize.w
  ) ? <span className="text-xs text-gray-400 ml-4">↔︎ scrollable</span> : null;

  const workingImageSizeText = workingImgSize ? (
    <sup className="text-xs text-gray-400 whitespace-nowrap">
      {`${workingImgSize.w} x ${workingImgSize.h} px`}
    </sup>
  ) : null;

  const workingImage = (
    <FadeIn className={`mb-6 ${resizedImgSrc || !energyMap ? 'hidden' : ''}`}>
      <div><b>Resized image</b> {workingImageSizeText} {workingImageScrollableText}</div>
      <div className="overflow-scroll">
        <canvas ref={canvasRef} />
        {seamsCanvas}
      </div>
    </FadeIn>
  );

  const resultImageSizeText = workingImgSize ? (
    <sup className="text-xs text-gray-400 whitespace-nowrap">
      {`${workingImgSize.w} x ${workingImgSize.h} px`}
    </sup>
  ) : null;

  const resultImage = workingImgSize && resizedImgSrc ? (
    <FadeIn className="mb-6">
      <div><b>Resized image</b> {resultImageSizeText}</div>
      <img src={resizedImgSrc} width={workingImgSize.w} height={workingImgSize.h} alt="Resized" style={{ margin: 0 }} />
    </FadeIn>
  ) : null;

  const debugEnergyMap = withEnergyMap && workingImgSize ? (
    <FadeIn className="mb-6">
      <div><b>Energy map</b></div>
      <EnergyMap energyMap={energyMap} width={workingImgSize.w} height={workingImgSize.h} />
      {seamsCanvas}
    </FadeIn>
  ) : null;

  const resizerControls = (
    <div className="flex flex-col justify-start items-start mb-1">

      <div className="mb-3 flex flex-row">
        <div className="mr-2">
          <FileSelector
            onSelect={onFileSelect}
            disabled={isResizing}
            accept="image/png,image/jpeg"
          >
            Choose image
          </FileSelector>
        </div>

        <div>
          <Button
            onClick={onResize}
            disabled={isResizing || !toWidthScaleString}
            startEnhancer={<ImShrink2 size={14} />}
          >
            Resize
          </Button>
        </div>
      </div>

      <div className="flex flex-col sm:flex-row">
        <div className="mb-2 mr-6 flex flex-row items-center">
          <div className="text-xs mr-1">Width</div>
          <Input
            onChange={onWidthSizeChange}
            disabled={isResizing}
            // @ts-ignore
            type="number"
            min={minScale}
            max={maxScale}
            className="w-14 text-center"
            value={toWidthScaleString}
          />
          <div className="text-xs ml-1 mr-4">%</div>

          <div className="text-xs mr-1">Height</div>
          <Input
            onChange={onHeightSizeChange}
            disabled={isResizing}
            // @ts-ignore
            type="number"
            min={minScale}
            max={maxScale}
            className="w-14 text-center"
            value={toHeightScaleString}
          />
          <div className="text-xs ml-1">%</div>
        </div>

        <div className="mb-2">
          <Checkbox disabled={isResizing} onChange={onUseOriginalSizeChange}>
            <span className="text-xs">
              Higher quality <span className="text-gray-400">(takes longer)</span>
            </span>
          </Checkbox>
        </div>
      </div>

    </div>
  );

  const progressBar = (
    <div className="mb-6">
      <Progress progress={progress} />
    </div>
  );

  return (
    <>
      {resizerControls}
      {progressBar}
      {workingImage}
      {resultImage}
      {debugEnergyMap}
      {originalImage}
    </>
  );
};

export default ImageResizer;

import React, { useEffect, useRef, useState } from 'react';
import { ImShrink2 } from '@react-icons/all-files/im/ImShrink2';
import { FaRegHandPointer } from '@react-icons/all-files/fa/FaRegHandPointer';

import {
  EnergyMap as EnergyMapType,
  Seam,
  OnIterationArgs,
  ImageSize,
  resizeImage,
  ALPHA_DELETE_THRESHOLD,
  MAX_WIDTH_LIMIT,
  MAX_HEIGHT_LIMIT,
} from '../utils/contentAwareResizer';
import EnergyMap from './EnergyMap';
import Seams from './Seams';
import defaultImgSrc from '../assets/02.jpg';
import Button, { BUTTON_KIND_SECONDARY } from './Button';
import FileSelector from './FileSelector';
import Checkbox from './Checkbox';
import Progress from './Progress';
import Input from './Input';
import FadeIn from './FadeIn';
import Mask from './Mask';
import { Coordinate, getPixel, setPixel } from '../utils/image';
import { MdLayersClear } from '@react-icons/all-files/md/MdLayersClear';

const defaultWidthScale = 50;
const defaultHeightScale = 70;
const minScale = 1;
const maxScale = 100;
const maxWidthLimit = MAX_WIDTH_LIMIT;
const maxHeightLimit = MAX_HEIGHT_LIMIT;

type ImageResizerProps = {
  withSeam?: boolean,
  withEnergyMap?: boolean,
};

const ImageResizer = (props: ImageResizerProps): React.ReactElement => {
  const {
    withSeam = false,
    withEnergyMap = false,
  } = props;

  const [imgAuthor, setImgAuthor] = useState<string | null>('ian dooley');
  const [imgAuthorURL, setImgAuthorURL] = useState<string | null>(
    'https://unsplash.com/@sadswim?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText',
  );

  const [useNaturalSize, setUseNaturalSize] = useState<boolean>(false);
  const [imageSrc, setImageSrc] = useState<string>(defaultImgSrc);
  const [resizedImgSrc, setResizedImgSrc] = useState<string | null>(null);
  const [energyMap, setEnergyMap] = useState<EnergyMapType | null>(null);
  const [originalImgSize, setOriginalImgSize] = useState<ImageSize | null>(null);
  const [originalImgViewSize, setOriginalImgViewSize] = useState<ImageSize | null>(null);
  const [workingImgSize, setWorkingImgSize] = useState<ImageSize | null>(null);
  const [seams, setSeams] = useState<Seam[] | null>(null);
  const [isResizing, setIsResizing] = useState<boolean>(false);
  const [progress, setProgress] = useState<number>(0);
  const [maskImgData, setMaskImgData] = useState<ImageData | null>(null);
  const [maskRevision, setMaskRevision] = useState<number>(0);
  const [toWidthScale, setToWidthScale] = useState<number>(defaultWidthScale);
  const [toWidthScaleString, setToWidthScaleString] = useState<string | undefined>(`${defaultWidthScale}`);
  const [toHeightScale, setToHeightScale] = useState<number>(defaultHeightScale);
  const [toHeightScaleString, setToHeightScaleString] = useState<string | undefined>(`${defaultHeightScale}`);

  const imgRef = useRef<HTMLImageElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  const onUseOriginalSizeChange = (state: boolean): void => {
    setUseNaturalSize(state);
  };

  const onReset = (): void => {
    setResizedImgSrc(null);
    setSeams(null);
    setWorkingImgSize(null);
    setEnergyMap(null);
    setProgress(0);
    setOriginalImgViewSize(null);
  };

  const onFileSelect = (files: FileList | null): void => {
    if (!files || !files.length) {
      return;
    }
    setImgAuthor(null);
    setImgAuthorURL(null);
    onReset();
    const imageURL = URL.createObjectURL(files[0]);
    setImageSrc(imageURL);
  };

  const onWidthSizeChange = (size: string | undefined): void => {
    const radix = 10;
    const scale = Math.max(Math.min(parseInt(size || '0', radix), maxScale), minScale);
    if (size) {
      setToWidthScaleString(`${scale}`);
    } else {
      setToWidthScaleString(size);
    }
    setToWidthScale(scale);
  };

  const onHeightSizeChange = (size: string | undefined): void => {
    const radix = 10;
    const scale = Math.max(Math.min(parseInt(size || '0', radix), maxScale), minScale);
    if (size) {
      setToHeightScaleString(`${scale}`);
    } else {
      setToHeightScaleString(size);
    }
    setToHeightScale(scale);
  };

  const onFinish = (): void => {
    if (!canvasRef.current) {
      return;
    }
    const imageType = 'image/png';
    canvasRef.current.toBlob((blob: Blob | null): void => {
      if (!blob) {
        return;
      }
      const imgUrl = URL.createObjectURL(blob);
      setResizedImgSrc(imgUrl);
      setIsResizing(false);
    }, imageType);
  };

  const onClearMask = (): void => {
    setMaskRevision(maskRevision + 1);
  };

  const onMaskDrawEnd = (imgData: ImageData): void => {
    setMaskImgData(imgData);
  };

  const applyMask = (img: ImageData): void => {
    if (!maskImgData) {
      return;
    }

    const wRatio = maskImgData.width / img.width;
    const hRatio = maskImgData.height / img.height;

    const imgXYtoMaskXY = ({ x: imgX, y: imgY }: Coordinate): Coordinate => {
      return {
        x: Math.floor(imgX * wRatio),
        y: Math.floor(imgY * hRatio),
      };
    };

    for (let y = 0; y < img.height; y += 1) {
      for (let x = 0; x < img.width; x += 1) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [mR, mG, mB, mA] = getPixel(
          maskImgData,
          imgXYtoMaskXY({ x, y }),
        );
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [iR, iG, iB, iA] = getPixel(img, { x, y });
        if (mA) {
          setPixel(img, { x, y }, [iR, iG, iB, ALPHA_DELETE_THRESHOLD]);
        }
      }
    }
  };

  const onIteration = async (args: OnIterationArgs): Promise<void> => {
    const {
      seam,
      img,
      energyMap: nrgMap,
      size: { w, h },
      step,
      steps,
    } = args;

    const canvas: HTMLCanvasElement | null = canvasRef.current;
    if (!canvas) {
      return;
    }

    canvas.width = w;
    canvas.height = h;

    const ctx: CanvasRenderingContext2D | null = canvas.getContext('2d');
    if (!ctx) {
      return;
    }

    ctx.putImageData(img, 0, 0, 0, 0, w, h);

    setEnergyMap(nrgMap);
    setSeams([seam]);
    setWorkingImgSize({ w, h });
    setProgress(step / steps);
  };

  const onResize = (): void => {
    const srcImg: HTMLImageElement | null = imgRef.current;
    if (!srcImg) {
      return;
    }
    const canvas: HTMLCanvasElement | null = canvasRef.current;
    if (!canvas) {
      return;
    }

    onReset();
    setIsResizing(true);

    let w = useNaturalSize ? srcImg.naturalWidth : srcImg.width;
    let h = useNaturalSize ? srcImg.naturalHeight : srcImg.height;
    const ratio = w / h;

    setOriginalImgViewSize({
      w: srcImg.width,
      h: srcImg.height,
    });

    if (w > maxWidthLimit) {
      w = maxWidthLimit;
      h = Math.floor(w / ratio);
    }

    if (h > maxHeightLimit) {
      h = maxHeightLimit;
      w = Math.floor(h * ratio);
    }

    canvas.width = w;
    canvas.height = h;

    const ctx: CanvasRenderingContext2D | null = canvas.getContext('2d');
    if (!ctx) {
      return;
    }

    ctx.drawImage(srcImg, 0, 0, w, h);

    const img: ImageData = ctx.getImageData(0, 0, w, h);

    applyMask(img);

    const toWidth = Math.floor((toWidthScale * w) / 100);
    const toHeight = Math.floor((toHeightScale * h) / 100);

    resizeImage({
      img,
      toWidth,
      toHeight,
      onIteration,
    }).then(() => {
      onFinish();
    });
  };

  useEffect(() => {
    const srcImg: HTMLImageElement | null = imgRef.current;
    if (!srcImg) {
      return;
    }
    srcImg.addEventListener('load', () => {
      if (!imgRef.current) {
        return;
      }
      setOriginalImgSize({
        w: imgRef.current.naturalWidth,
        h: imgRef.current.naturalHeight,
      });
      setOriginalImgViewSize({
        w: imgRef.current.width,
        h: imgRef.current.height,
      });
    });
  }, []);

  useEffect(() => {
    function updateSize(): void {
      if (!imgRef.current) {
        return;
      }
      setOriginalImgViewSize({
        w: imgRef.current.width,
        h: imgRef.current.height,
      });
    }
    window.addEventListener('resize', updateSize);
    return (): void => {
      window.removeEventListener('resize', updateSize);
    };
  }, []);

  const imgAuthorLink = imgAuthor && imgAuthorURL ? (
    <div className="text-xs text-gray-400 mt-2 flex justify-center items-center font-light">
      <div className="mr-1">
        Photo by
      </div>
      <a
        href={imgAuthorURL}
        style={{ color: '#aaa', fontWeight: 300 }}
        target="_blank"
        rel="noreferrer"
      >
        {imgAuthor}
      </a>
    </div>
  ) : null;

  const seamsCanvas = withSeam && workingImgSize && seams ? (
    <div style={{ marginTop: `-${workingImgSize.h}px` }}>
      <Seams seams={seams} width={workingImgSize.w} height={workingImgSize.h} />
    </div>
  ) : null;

  const originalImageSizeText = originalImgSize ? (
    <sup className="text-xs text-gray-400 whitespace-nowrap">
      {`${originalImgSize.w} x ${originalImgSize.h} px`}
    </sup>
  ) : null;

  const maskControls = (
    <div>
      <Button
        onClick={onClearMask}
        disabled={isResizing || !maskImgData}
        kind={BUTTON_KIND_SECONDARY}
        title="Clear mask"
        className="rounded-full"
        style={{ padding: '8px 8px', border: 0, outline: 'none' }}
      >
        <MdLayersClear size={16} />
      </Button>
    </div>
  );

  const mask = originalImgViewSize ? (
    <div className="flex flex-col" style={{ marginTop: `-${originalImgViewSize.h}px` }}>
      <Mask
        width={originalImgViewSize.w}
        height={originalImgViewSize.h}
        disabled={isResizing}
        onDrawEnd={onMaskDrawEnd}
        revision={maskRevision}
      />
      <div className="flex flex-row justify-end" style={{ marginTop: '-36px', zIndex: 100 }}>
        <div className="mr-1">
          {maskControls}
        </div>
      </div>
    </div>
  ) : null;

  const originalImage = (
    <FadeIn>
      <div className="flex flex-row justify-center items-center mb-1 sm:mb-0">
        <div className="flex-1 sm:flex sm:flex-row sm:items-center">
          <div className="sm:flex-1">
            <b>Original image</b> {originalImageSizeText}
          </div>
          <div className="text-xs text-gray-400 flex flex-row items-center justify-self-end">
            <div className="mr-1">
              <FaRegHandPointer size={12} />
            </div>
            <div>
              Mask to remove
            </div>
          </div>
        </div>
      </div>
      <img src={imageSrc} alt="Original" ref={imgRef} style={{ margin: 0 }} />
      {mask}
      {imgAuthorLink}
    </FadeIn>
  );

  const workingImageScrollableText = (
    workingImgSize?.w && originalImgViewSize?.w && workingImgSize.w > originalImgViewSize.w
  ) ? <span className="text-xs text-gray-400 ml-4">↔︎ scrollable</span> : null;

  const workingImageSizeText = workingImgSize ? (
    <sup className="text-xs text-gray-400 whitespace-nowrap">
      {`${workingImgSize.w} x ${workingImgSize.h} px`}
    </sup>
  ) : null;

  const workingImage = (
    <FadeIn className={`mb-6 ${resizedImgSrc || !energyMap ? 'hidden' : ''}`}>
      <div><b>Resized image</b> {workingImageSizeText} {workingImageScrollableText}</div>
      <div className="overflow-scroll">
        <canvas ref={canvasRef} />
        {seamsCanvas}
      </div>
    </FadeIn>
  );

  const resultImageSizeText = workingImgSize ? (
    <sup className="text-xs text-gray-400 whitespace-nowrap">
      {`${workingImgSize.w} x ${workingImgSize.h} px`}
    </sup>
  ) : null;

  const resultImage = workingImgSize && resizedImgSrc ? (
    <FadeIn className="mb-6">
      <div><b>Resized image</b> {resultImageSizeText}</div>
      <img src={resizedImgSrc} width={workingImgSize.w} height={workingImgSize.h} alt="Resized" style={{ margin: 0 }} />
    </FadeIn>
  ) : null;

  const debugEnergyMap = withEnergyMap && workingImgSize ? (
    <FadeIn className="mb-6">
      <div><b>Energy map</b></div>
      <EnergyMap energyMap={energyMap} width={workingImgSize.w} height={workingImgSize.h} />
      {seamsCanvas}
    </FadeIn>
  ) : null;

  const resizerControls = (
    <div className="flex flex-col justify-start items-start mb-1">

      <div className="mb-3 flex flex-row">
        <div className="mr-2">
          <FileSelector
            onSelect={onFileSelect}
            disabled={isResizing}
            accept="image/png,image/jpeg"
          >
            Choose image
          </FileSelector>
        </div>

        <div>
          <Button
            onClick={onResize}
            disabled={isResizing || !toWidthScaleString}
            startEnhancer={<ImShrink2 size={14} />}
          >
            Resize
          </Button>
        </div>
      </div>

      <div className="flex flex-col sm:flex-row">
        <div className="mb-2 mr-6 flex flex-row items-center">
          <div className="text-xs mr-1">Width</div>
          <Input
            onChange={onWidthSizeChange}
            disabled={isResizing}
            // @ts-ignore
            type="number"
            min={minScale}
            max={maxScale}
            className="w-14 text-center"
            value={toWidthScaleString}
          />
          <div className="text-xs ml-1 mr-4">%</div>

          <div className="text-xs mr-1">Height</div>
          <Input
            onChange={onHeightSizeChange}
            disabled={isResizing}
            // @ts-ignore
            type="number"
            min={minScale}
            max={maxScale}
            className="w-14 text-center"
            value={toHeightScaleString}
          />
          <div className="text-xs ml-1">%</div>
        </div>

        <div className="mb-2">
          <Checkbox disabled={isResizing} onChange={onUseOriginalSizeChange}>
            <span className="text-xs">
              Higher quality <span className="text-gray-400">(takes longer)</span>
            </span>
          </Checkbox>
        </div>
      </div>

    </div>
  );

  const progressBar = (
    <div className="mb-6">
      <Progress progress={progress} />
    </div>
  );

  return (
    <>
      {resizerControls}
      {progressBar}
      {workingImage}
      {resultImage}
      {debugEnergyMap}
      {originalImage}
    </>
  );
};

export default ImageResizer;

import React, { useRef, useEffect } from 'react';
import { Seam } from '../utils/contentAwareResizer';
import { Coordinate } from '../utils/image';

type SeamProps = {
  seams: Seam[],
  width: number,
  height: number,
  className?: string,
};

const Seams = (props: SeamProps): React.ReactElement => {
  const {
    seams,
    width,
    height,
    className = '',
  } = props;

  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    if (!seams || !seams.length || !seams[0]) {
      return;
    }
    const seamsCanvas: HTMLCanvasElement | null = canvasRef.current;
    if (!seamsCanvas) {
      return;
    }
    const seamsCtx: CanvasRenderingContext2D | null = seamsCanvas.getContext('2d');
    if (!seamsCtx) {
      return;
    }

    seamsCanvas.width = width;
    seamsCanvas.height = height;

    seamsCtx.fillStyle = 'rgba(255, 255, 255, 1)';
    seams[0].forEach(({ x, y }: Coordinate) => {
      seamsCtx.fillRect(x, y, 1, 1);
    });
  }, [seams, width, height]);

  return (
    <canvas ref={canvasRef} className={className} />
  );
};

export default Seams;
/* eslint-disable no-await-in-loop, no-param-reassign, object-curly-newline */
import {
    Color,
    Coordinate,
    getPixel,
    setPixel,
  } from './image';
  import { wait } from './time';
  
  export type Seam = Coordinate[];
  export type EnergyMap = number[][];
  
  type SeamMeta = {
    energy: number,
    coordinate: Coordinate,
    previous: Coordinate | null,
  };
  
  export type ImageSize = { w: number, h: number };
  
  export type OnIterationArgs = {
    seam: Seam,
    img: ImageData,
    size: ImageSize,
    energyMap: EnergyMap,
    step: number,
    steps: number,
  };
  
  // If pixel's alpha is lower than the threshold this pixel is going to have
  // the lowest energy and thus is a candidate for deletion.
  export const ALPHA_DELETE_THRESHOLD = 244;
  
  export const MAX_WIDTH_LIMIT = 1500;
  export const MAX_HEIGHT_LIMIT = 1500;
  
  const getPixelDeleteEnergy = (): number => {
    const numColors = 3;
    const maxColorDistance = 255;
    const numNeighbors = 2;
    const multiplier = 2;
    const maxSeamSize = Math.max(MAX_WIDTH_LIMIT, MAX_HEIGHT_LIMIT);
    return -1 * multiplier * numNeighbors * maxSeamSize * numColors * (maxColorDistance ** 2);
  };
  
  const matrix = <T>(w: number, h: number, filler: T): T[][] => {
    return new Array(h)
      .fill(null)
      .map(() => {
        return new Array(w).fill(filler);
      });
  };
  
  const getPixelEnergy = (left: Color | null, middle: Color, right: Color | null): number => {
    const [mR, mG, mB, mA] = middle;
  
    let lEnergy = 0;
    if (left) {
      const [lR, lG, lB] = left;
      lEnergy = (lR - mR) ** 2 + (lG - mG) ** 2 + (lB - mB) ** 2;
    }
  
    let rEnergy = 0;
    if (right) {
      const [rR, rG, rB] = right;
      rEnergy = (rR - mR) ** 2 + (rG - mG) ** 2 + (rB - mB) ** 2;
    }
  
    return mA > ALPHA_DELETE_THRESHOLD ? (lEnergy + rEnergy) : getPixelDeleteEnergy();
  };
  
  const getPixelEnergyH = (img: ImageData, { w }: ImageSize, { x, y }: Coordinate): number => {
    const left = (x - 1) >= 0 ? getPixel(img, { x: x - 1, y }) : null;
    const middle = getPixel(img, { x, y });
    const right = (x + 1) < w ? getPixel(img, { x: x + 1, y }) : null;
    return getPixelEnergy(left, middle, right);
  };
  
  const getPixelEnergyV = (img: ImageData, { h }: ImageSize, { x, y }: Coordinate): number => {
    const top = (y - 1) >= 0 ? getPixel(img, { x, y: y - 1 }) : null;
    const middle = getPixel(img, { x, y });
    const bottom = (y + 1) < h ? getPixel(img, { x, y: y + 1 }) : null;
    return getPixelEnergy(top, middle, bottom);
  };
  
  const calculateEnergyMapH = (img: ImageData, { w, h }: ImageSize): EnergyMap => {
    const energyMap: number[][] = matrix<number>(w, h, Infinity);
    for (let y = 0; y < h; y += 1) {
      for (let x = 0; x < w; x += 1) {
        energyMap[y][x] = getPixelEnergyH(img, { w, h }, { x, y });
      }
    }
    return energyMap;
  };
  
  const calculateEnergyMapV = (img: ImageData, { w, h }: ImageSize): EnergyMap => {
    const energyMap: number[][] = matrix<number>(w, h, Infinity);
    for (let y = 0; y < h; y += 1) {
      for (let x = 0; x < w; x += 1) {
        energyMap[y][x] = getPixelEnergyV(img, { w, h }, { x, y });
      }
    }
    return energyMap;
  };
  
  const reCalculateEnergyMapH = (
    img: ImageData,
    { w, h }: ImageSize,
    energyMap: EnergyMap,
    seam: Seam,
  ): EnergyMap => {
    seam.forEach(({ x: seamX, y: seamY }: Coordinate) => {
      // Deleting the seam from the energy map.
      for (let x = seamX; x < (w - 1); x += 1) {
        energyMap[seamY][x] = energyMap[seamY][x + 1];
      }
      // Recalculating the energy pixels around the deleted seam.
      energyMap[seamY][seamX] = getPixelEnergyH(img, { w, h }, { x: seamX, y: seamY });
    });
    return energyMap;
  };
  
  const reCalculateEnergyMapV = (
    img: ImageData,
    { w, h }: ImageSize,
    energyMap: EnergyMap,
    seam: Seam,
  ): EnergyMap => {
    seam.forEach(({ x: seamX, y: seamY }: Coordinate) => {
      // Deleting the seam from the energy map.
      for (let y = seamY; y < (h - 1); y += 1) {
        energyMap[y][seamX] = energyMap[y + 1][seamX];
      }
      // Recalculating the energy pixels around the deleted seam.
      energyMap[seamY][seamX] = getPixelEnergyV(img, { w, h }, { x: seamX, y: seamY });
    });
    return energyMap;
  };
  
  const findLowEnergySeamH = (energyMap: EnergyMap, { w, h }: ImageSize): Seam => {
    const seamsMap: (SeamMeta | null)[][] = matrix<SeamMeta | null>(w, h, null);
  
    // Populate the first row of the map.
    for (let x = 0; x < w; x += 1) {
      const y = 0;
      seamsMap[y][x] = {
        energy: energyMap[y][x],
        coordinate: { x, y },
        previous: null,
      };
    }
  
    // Populate the rest of the rows.
    for (let y = 1; y < h; y += 1) {
      for (let x = 0; x < w; x += 1) {
        // Find top adjacent cell with minimum energy.
        let minPrevEnergy = Infinity;
        let minPrevX: number = x;
        for (let i = (x - 1); i <= (x + 1); i += 1) {
          // @ts-ignore
          if (i >= 0 && i < w && seamsMap[y - 1][i].energy < minPrevEnergy) {
            // @ts-ignore
            minPrevEnergy = seamsMap[y - 1][i].energy;
            minPrevX = i;
          }
        }
  
        // Update the current cell.
        seamsMap[y][x] = {
          energy: minPrevEnergy + energyMap[y][x],
          coordinate: { x, y },
          previous: { x: minPrevX, y: y - 1 },
        };
      }
    }
  
    // Find where the minimum energy seam ends.
    let lastMinCoordinate: Coordinate | null = null;
    let minSeamEnergy = Infinity;
    for (let x = 0; x < w; x += 1) {
      const y = h - 1;
      // @ts-ignore
      if (seamsMap[y][x].energy < minSeamEnergy) {
        // @ts-ignore
        minSeamEnergy = seamsMap[y][x].energy;
        lastMinCoordinate = { x, y };
      }
    }
  
    // Find the minimal energy seam.
    const seam: Seam = [];
    if (!lastMinCoordinate) {
      return seam;
    }
  
    const { x: lastMinX, y: lastMinY } = lastMinCoordinate;
  
    let currentSeam = seamsMap[lastMinY][lastMinX];
    while (currentSeam) {
      seam.push(currentSeam.coordinate);
      const prevMinCoordinates = currentSeam.previous;
      if (!prevMinCoordinates) {
        currentSeam = null;
      } else {
        const { x: prevMinX, y: prevMinY } = prevMinCoordinates;
        currentSeam = seamsMap[prevMinY][prevMinX];
      }
    }
  
    return seam;
  };
  
  const findLowEnergySeamV = (energyMap: EnergyMap, { w, h }: ImageSize): Seam => {
    const seamsMap: (SeamMeta | null)[][] = matrix<SeamMeta | null>(w, h, null);
  
    // Populate the first column of the map.
    for (let y = 0; y < h; y += 1) {
      const x = 0;
      seamsMap[y][x] = {
        energy: energyMap[y][x],
        coordinate: { x, y },
        previous: null,
      };
    }
  
    // Populate the rest of the columns.
    for (let x = 1; x < w; x += 1) {
      for (let y = 0; y < h; y += 1) {
        // Find left adjacent cell with minimum energy.
        let minPrevEnergy = Infinity;
        let minPrevY: number = y;
        for (let i = (y - 1); i <= (y + 1); i += 1) {
          // @ts-ignore
          if (i >= 0 && i < h && seamsMap[i][x - 1].energy < minPrevEnergy) {
            // @ts-ignore
            minPrevEnergy = seamsMap[i][x - 1].energy;
            minPrevY = i;
          }
        }
  
        // Update the current cell.
        seamsMap[y][x] = {
          energy: minPrevEnergy + energyMap[y][x],
          coordinate: { x, y },
          previous: { x: x - 1, y: minPrevY },
        };
      }
    }
  
    // Find where the minimum energy seam ends.
    let lastMinCoordinate: Coordinate | null = null;
    let minSeamEnergy = Infinity;
    for (let y = 0; y < h; y += 1) {
      const x = w - 1;
      // @ts-ignore
      if (seamsMap[y][x].energy < minSeamEnergy) {
        // @ts-ignore
        minSeamEnergy = seamsMap[y][x].energy;
        lastMinCoordinate = { x, y };
      }
    }
  
    // Find the minimal energy seam.
    const seam: Seam = [];
    if (!lastMinCoordinate) {
      return seam;
    }
  
    const { x: lastMinX, y: lastMinY } = lastMinCoordinate;
  
    let currentSeam = seamsMap[lastMinY][lastMinX];
    while (currentSeam) {
      seam.push(currentSeam.coordinate);
      const prevMinCoordinates = currentSeam.previous;
      if (!prevMinCoordinates) {
        currentSeam = null;
      } else {
        const { x: prevMinX, y: prevMinY } = prevMinCoordinates;
        currentSeam = seamsMap[prevMinY][prevMinX];
      }
    }
  
    return seam;
  };
  
  const deleteSeamH = (img: ImageData, seam: Seam, { w }: ImageSize): void => {
    seam.forEach(({ x: seamX, y: seamY }: Coordinate) => {
      for (let x = seamX; x < (w - 1); x += 1) {
        const nextPixel = getPixel(img, { x: x + 1, y: seamY });
        setPixel(img, { x, y: seamY }, nextPixel);
      }
    });
  };
  
  const deleteSeamV = (img: ImageData, seam: Seam, { h }: ImageSize): void => {
    seam.forEach(({ x: seamX, y: seamY }: Coordinate) => {
      for (let y = seamY; y < (h - 1); y += 1) {
        const nextPixel = getPixel(img, { x: seamX, y: y + 1 });
        setPixel(img, { x: seamX, y }, nextPixel);
      }
    });
  };
  
  type ResizeAxisArgs = {
    img: ImageData,
    toSize: number,
    size: ImageSize,
    onIteration?: (args: OnIterationArgs) => Promise<void>,
  };
  
  type ResizeImageArgs = {
    img: ImageData,
    toWidth: number,
    toHeight: number,
    onIteration?: (args: OnIterationArgs) => Promise<void>,
  };
  
  const resizeImageWidth = async (args: ResizeAxisArgs): Promise<void> => {
    const { img, toSize, onIteration, size } = args;
  
    const pxToRemove = img.width - toSize;
    if (pxToRemove < 0) {
      throw new Error('Upsizing is not supported');
    }
  
    let energyMap: EnergyMap | null = null;
    let seam: Seam | null = null;
  
    for (let i = 0; i < pxToRemove; i += 1) {
      energyMap = energyMap && seam
        ? reCalculateEnergyMapH(img, size, energyMap, seam)
        : calculateEnergyMapH(img, size);
  
      seam = findLowEnergySeamH(energyMap, size);
  
      deleteSeamH(img, seam, size);
  
      if (onIteration) {
        await onIteration({
          energyMap,
          seam,
          img,
          size,
          step: i,
          steps: pxToRemove,
        });
      }
  
      size.w -= 1;
  
      await wait(1);
    }
  };
  
  const resizeImageHeight = async (args: ResizeAxisArgs): Promise<void> => {
    const { img, toSize, onIteration, size } = args;
  
    const pxToRemove = img.height - toSize;
    if (pxToRemove < 0) {
      throw new Error('Upsizing is not supported');
    }
  
    let energyMap: EnergyMap | null = null;
    let seam: Seam | null = null;
  
    for (let i = 0; i < pxToRemove; i += 1) {
      energyMap = energyMap && seam
        ? reCalculateEnergyMapV(img, size, energyMap, seam)
        : calculateEnergyMapV(img, size);
  
      seam = findLowEnergySeamV(energyMap, size);
  
      deleteSeamV(img, seam, size);
  
      if (onIteration) {
        await onIteration({
          energyMap,
          seam,
          img,
          size,
          step: i,
          steps: pxToRemove,
        });
      }
  
      size.h -= 1;
  
      await wait(1);
    }
  };
  
  export const resizeImage = async (args: ResizeImageArgs): Promise<void> => {
    const {
      img,
      toWidth,
      toHeight,
      onIteration,
    } = args;
  
    const pxToRemoveH = img.width - toWidth;
    const pxToRemoveV = img.height - toHeight;
  
    const size: ImageSize = { w: img.width, h: img.height };
  
    const globalSteps = pxToRemoveH + pxToRemoveV;
    let globalStep = 0;
  
    const onResizeIteration = async (onIterationArgs: OnIterationArgs): Promise<void> => {
      const {
        seam,
        img: onIterationImg,
        size: onIterationSize,
        energyMap,
      } = onIterationArgs;
  
      globalStep += 1;
  
      if (!onIteration) {
        return;
      }
  
      await onIteration({
        seam,
        img: onIterationImg,
        size: onIterationSize,
        energyMap,
        step: globalStep,
        steps: globalSteps,
      });
    };
  
    await resizeImageWidth({ img, toSize: toWidth, onIteration: onResizeIteration, size });
    await resizeImageHeight({ img, toSize: toHeight, onIteration: onResizeIteration, size });
  };
  /* eslint-disable no-await-in-loop, no-param-reassign, object-curly-newline */
import {
    Color,
    Coordinate,
    getPixel,
    setPixel,
  } from './image';
  
  // The seam is a sequence of pixels (coordinates).
  export type Seam = Coordinate[];
  
  // Energy map is a 2D array that has the same width and height
  // as the image the map is being calculated for.
  export type EnergyMap = number[][];
  
  // The metadata for the pixels in the seam.
  type SeamPixelMeta = {
    energy: number, // The energy of the pixel.
    coordinate: Coordinate, // The coordinate of the pixel.
    previous: Coordinate | null, // The previous pixel in a seam.
  };
  
  // Type that describes the image size (width and height)
  export type ImageSize = { w: number, h: number };
  
  // Arguments that are being passed to the onIteration() callback.
  export type OnIterationArgs = {
    seam: Seam, // The current lowest energy seam.
    img: ImageData, // The current version of the image data.
    size: ImageSize, // The current image size.
    energyMap: EnergyMap, // The energy map.
    step: number,
    steps: number,
  };
  
  // Helper function that creates a matrix (2D array) of specific
  // size (w x h) and fills it with specified value.
  const matrix = <T>(w: number, h: number, filler: T): T[][] => {
    return new Array(h)
      .fill(null)
      .map(() => {
        return new Array(w).fill(filler);
      });
  };
  
  // Calculates the energy of a pixel.
  const getPixelEnergy = (left: Color | null, middle: Color, right: Color | null): number => {
    // Middle pixel is the pixel we're calculating the energy for.
    const [mR, mG, mB] = middle;
  
    // Energy from the left pixel (if it exists).
    let lEnergy = 0;
    if (left) {
      const [lR, lG, lB] = left;
      lEnergy = (lR - mR) ** 2 + (lG - mG) ** 2 + (lB - mB) ** 2;
    }
  
    // Energy from the right pixel (if it exists).
    let rEnergy = 0;
    if (right) {
      const [rR, rG, rB] = right;
      rEnergy = (rR - mR) ** 2 + (rG - mG) ** 2 + (rB - mB) ** 2;
    }
  
    // Resulting pixel energy.
    return Math.sqrt(lEnergy + rEnergy);
  };
  
  // Calculates the energy of each pixel of the image.
  const calculateEnergyMap = (img: ImageData, { w, h }: ImageSize): EnergyMap => {
    // Create an empty energy map where each pixel has infinitely high energy.
    // We will update the energy of each pixel.
    const energyMap: number[][] = matrix<number>(w, h, Infinity);
    for (let y = 0; y < h; y += 1) {
      for (let x = 0; x < w; x += 1) {
        // Left pixel might not exist if we're on the very left edge of the image.
        const left = (x - 1) >= 0 ? getPixel(img, { x: x - 1, y }) : null;
        // The color of the middle pixel that we're calculating the energy for.
        const middle = getPixel(img, { x, y });
        // Right pixel might not exist if we're on the very right edge of the image.
        const right = (x + 1) < w ? getPixel(img, { x: x + 1, y }) : null;
        energyMap[y][x] = getPixelEnergy(left, middle, right);
      }
    }
    return energyMap;
  };
  
  // Finds the seam (the sequence of pixels from top to bottom) that has the
  // lowest resulting energy using the Dynamic Programming approach.
  const findLowEnergySeam = (energyMap: EnergyMap, { w, h }: ImageSize): Seam => {
    // The 2D array of the size of w and h, where each pixel contains the
    // seam metadata (pixel energy, pixel coordinate and previous pixel from
    // the lowest energy seam at this point).
    const seamPixelsMap: (SeamPixelMeta | null)[][] = matrix<SeamPixelMeta | null>(w, h, null);
  
    // Populate the first row of the map by just copying the energies
    // from the energy map.
    for (let x = 0; x < w; x += 1) {
      const y = 0;
      seamPixelsMap[y][x] = {
        energy: energyMap[y][x],
        coordinate: { x, y },
        previous: null,
      };
    }
  
    // Populate the rest of the rows.
    for (let y = 1; y < h; y += 1) {
      for (let x = 0; x < w; x += 1) {
        // Find the top adjacent cell with minimum energy.
        // This cell would be the tail of a seam with lowest energy at this point.
        // It doesn't mean that this seam (path) has lowest energy globally.
        // Instead, it means that we found a path with the lowest energy that may lead
        // us to the current pixel with the coordinates x and y.
        let minPrevEnergy = Infinity;
        let minPrevX: number = x;
        for (let i = (x - 1); i <= (x + 1); i += 1) {
          // @ts-ignore
          if (i >= 0 && i < w && seamPixelsMap[y - 1][i].energy < minPrevEnergy) {
            // @ts-ignore
            minPrevEnergy = seamPixelsMap[y - 1][i].energy;
            minPrevX = i;
          }
        }
  
        // Update the current cell.
        seamPixelsMap[y][x] = {
          energy: minPrevEnergy + energyMap[y][x],
          coordinate: { x, y },
          previous: { x: minPrevX, y: y - 1 },
        };
      }
    }
  
    // Find where the minimum energy seam ends.
    // We need to find the tail of the lowest energy seam to start
    // traversing it from its tail to its head (from the bottom to the top).
    let lastMinCoordinate: Coordinate | null = null;
    let minSeamEnergy = Infinity;
    for (let x = 0; x < w; x += 1) {
      const y = h - 1;
      // @ts-ignore
      if (seamPixelsMap[y][x].energy < minSeamEnergy) {
        // @ts-ignore
        minSeamEnergy = seamPixelsMap[y][x].energy;
        lastMinCoordinate = { x, y };
      }
    }
  
    // Find the lowest energy energy seam.
    // Once we know where the tail is we may traverse and assemble the lowest
    // energy seam based on the "previous" value of the seam pixel metadata.
    const seam: Seam = [];
    if (!lastMinCoordinate) {
      return seam;
    }
  
    const { x: lastMinX, y: lastMinY } = lastMinCoordinate;
  
    // Adding new pixel to the seam path one by one until we reach the top.
    let currentSeam = seamPixelsMap[lastMinY][lastMinX];
    while (currentSeam) {
      seam.push(currentSeam.coordinate);
      const prevMinCoordinates = currentSeam.previous;
      if (!prevMinCoordinates) {
        currentSeam = null;
      } else {
        const { x: prevMinX, y: prevMinY } = prevMinCoordinates;
        currentSeam = seamPixelsMap[prevMinY][prevMinX];
      }
    }
  
    return seam;
  };
  
  // Deletes the seam from the image data.
  // We delete the pixel in each row and then shift the rest of the row pixels to the left.
  const deleteSeam = (img: ImageData, seam: Seam, { w }: ImageSize): void => {
    seam.forEach(({ x: seamX, y: seamY }: Coordinate) => {
      for (let x = seamX; x < (w - 1); x += 1) {
        const nextPixel = getPixel(img, { x: x + 1, y: seamY });
        setPixel(img, { x, y: seamY }, nextPixel);
      }
    });
  };
  
  type ResizeImageWidthArgs = {
    img: ImageData, // Image data we want to resize.
    toWidth: number, // Final image width we want the image to shrink to.
  };
  
  type ResizeImageWidthResult = {
    img: ImageData, // Resized image data.
    size: ImageSize, // Resized image size (w x h).
  };
  
  // Performs the content-aware image width resizing using the seam carving method.
  export const resizeImageWidth = (
    { img, toWidth }: ResizeImageWidthArgs,
  ): ResizeImageWidthResult => {
    // For performance reasons we want to avoid changing the img data array size.
    // Instead we'll just keep the record of the resized image width and height separately.
    const size: ImageSize = { w: img.width, h: img.height };
  
    // Calculating the number of pixels to remove.
    const pxToRemove = img.width - toWidth;
    if (pxToRemove < 0) {
      throw new Error('Upsizing is not supported for now');
    }
  
    let energyMap: EnergyMap | null = null;
    let seam: Seam | null = null;
  
    // Removing the lowest energy seams one by one.
    for (let i = 0; i < pxToRemove; i += 1) {
      // 1. Calculate the energy map for the current version of the image.
      energyMap = calculateEnergyMap(img, size);
  
      // 2. Find the seam with the lowest energy based on the energy map.
      seam = findLowEnergySeam(energyMap, size);
  
      // 3. Delete the seam with the lowest energy seam from the image.
      deleteSeam(img, seam, size);
  
      // Reduce the image width, and continue iterations.
      size.w -= 1;
    }
  
    // Returning the resized image and its final size.
    // The img is actually a reference to the ImageData, so technically
    // the caller of the function already has this pointer. But let's
    // still return it for better code readability.
    return { img, size };
  };